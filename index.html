<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        body {
            padding: 20px;
            margin: 0;
        }

        #field {
            position: relative;
            padding: 0;
            width: 600px;
            height: 600px;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            border: 1px solid #000;
        }

        #field span {
            display: flex;
            width: 100%;
            height: 100%;
            text-align: center;
            box-sizing: border-box;
            border: 1px solid #000;
            cursor: pointer;
            justify-items: center;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            background-image: url(images/grass.png);
            background-size: 100% auto;
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="field"></div>
    <div>
        <p>Время игры: <span id="timer">0</span> секунд / Количество ходов: <span id="moves">0</span></p>
        <button id="restartButton">Перезапустить игру</button>
    </div>

    <script>
        // игровое поле
        const fieldDIV = document.getElementById('field');

        // количество мин
        const totalMines = 10;
        // ширина поля
        const fieldWidth = 10;
        // высота поля
        const fieldHeight = 10;
        // TODO в стилях обновления размера поля обновлять

        // статус активности игры
        let isGameActive = true;

        // рандомные мины
        const mines = [];
        // генерация уникальных координат мин
        while (mines.length < totalMines) {
            const randomWidth = Math.floor((Math.random() * fieldWidth) + 0);
            const randomHeight = Math.floor((Math.random() * fieldHeight) + 0);
            const newMine = [randomWidth, randomHeight];
            // проверка на уникальность координат при генерации
            if (!mines.some(mine => mine[0] === randomWidth && mine[1] === randomHeight)) {
                mines.push(newMine);
            }
        }

        // матрица поля
        const fieldMatrix = Array.from({ length: fieldWidth }, () => Array.from({ length: fieldHeight }, () => 0));

        // расстановка подсказок-чисел про мины вокруг поля
        // и расстановка самих мин
        for (const [x, y] of mines) {
            fieldMatrix[x][y] = '*';
            // направление поиска
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                if (newX >= 0 && newX < fieldWidth && newY >= 0 && newY < fieldHeight && fieldMatrix[newX][newY] !== '*') {
                    fieldMatrix[newX][newY]++;
                }
            }
        }

        // отрисовка поля
        for (let i = 0; i < fieldWidth; i++) {
            for (let j = 0; j < fieldHeight; j++) {
                const cell = document.createElement('span');
                cell.dataset.mines = fieldMatrix[i][j];
                cell.dataset.i = i;
                cell.dataset.j = j;
                cell.addEventListener('click', function () {
                    handleClick(this);
                });
                cell.addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                    handleRightClick(this);
                });
                fieldDIV.appendChild(cell);
            }
        }

        // таймер игры
        let timer = 0;
        const timerElement = document.getElementById('timer');
        const timerInterval = setInterval(() => {
            if (isGameActive) {
                timer++;
                timerElement.innerText = timer;
            }
        }, 1000);

        // количество ходов
        let moves = 0;
        const movesElement = document.getElementById('moves');

        // клик по блоку
        function handleClick(cell) {
            if (!isGameActive) {
                // игра закончена уже
                return true;
            }

            moves++;
            movesElement.innerText = moves;

            const mines = cell.dataset.mines;
            const cellRow = parseInt(cell.dataset.i);
            const cellCol = parseInt(cell.dataset.j);

            if (mines != "*") {
                if (mines > 0) {
                    cell.innerText = mines;
                    setColor(cell, mines);
                } else {
                    // поиск всех соседних пустых ячеек
                    const allEmptyCells = findAllEmptyCells(fieldMatrix, cellRow, cellCol);
                    // отрисовка пустот
                    for (let i = 0; i < allEmptyCells.length; i++) {
                        const emptyCell = document.querySelector(`span[data-i="${allEmptyCells[i][0]}"][data-j="${allEmptyCells[i][1]}"]`);
                        emptyCell.innerText = 0;
                        setColor(emptyCell, 0);
                    }
                }
                cell.innerText = mines;
                if (checkWin()) {
                    isGameActive = false;
                    clearInterval(timerInterval);
                    alert("Победа!");
                }
            } else {
                // проигрыш
                isGameActive = false;
                clearInterval(timerInterval);

                // показ всех мин
                const mineCells = document.querySelectorAll(`span[data-mines="*"]`);
                for (let i = 0; i < mineCells.length; i++) {
                    const mineCell = mineCells[i];
                    setColor(mineCell, "bomb");
                }
                setColor(cell, "bomb-fail");
                alert("Потрачено :(");
            }
        }

        // обработка правого клика для установки флага
        function handleRightClick(cell) {
            if (!isGameActive) {
                return true;
            }

            if (cell.style.backgroundImage === 'url("images/bomb-flag.png")') {
                cell.style.backgroundImage = 'url(images/grass.png)';
            } else {
                cell.style.backgroundImage = 'url(images/bomb-flag.png)';
            }
        }

        // проверка победы
        function checkWin() {
            const cells = document.querySelectorAll('span[data-mines]');
            for (const cell of cells) {
                if (cell.dataset.mines != "*" && cell.innerHTML.trim() == "") {
                    return false;
                }
            }
            return true;
        }

        // закрашивание ячеек
        function setColor(cell, mines) {
            cell.style.backgroundImage = 'none';
            if (mines == 0) {
                cell.style.backgroundColor = "#e0dfdf";
            } else if (mines == "bomb") {
                cell.style.backgroundImage = 'url(images/bomb.png)';
            } else if (mines == "bomb-fail") {
                cell.style.backgroundImage = 'url(images/bomb-fail.png)';
            } else {
                const colors = {
                    1: "#86c3f4",
                    2: "#6ba9e0",
                    3: "#4f8fcc",
                    4: "#3475b8",
                    5: "#195ba4",
                    6: "#004190",
                    7: "#00377c",
                    8: "#002d68"
                };
                cell.style.backgroundColor = colors[mines] || "#86c3f4";
            }
        }

        // поиск всех соседних пустых зон
        function findAllEmptyCells(matrix, startRow, startCol) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            // направление поиска
            const directions = [
                [-1, 0], // вверх
                [0, -1], // влево
                [1, 0],  // вниз
                [0, 1]   // вправо
            ];
            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
            const result = [];

            // рекурсивный поиск в глубину
            function dfs(row, col) {
                if (row < 0 || row >= rows || col < 0 || col >= cols || matrix[row][col] !== 0 || visited[row][col]) {
                    return;
                }
                visited[row][col] = true;
                result.push([row, col]);
                for (const [dx, dy] of directions) {
                    dfs(row + dx, col + dy);
                }
            }
            dfs(startRow, startCol);
            return result;
        }

        // перезапуск игры
        document.getElementById('restartButton').addEventListener('click', function () {
            location.reload();
        });
    </script>
</body>

</html>